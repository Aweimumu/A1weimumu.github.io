{"meta":{"title":"Awei","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"2022-7-22","date":"2022-07-19T22:57:07.224Z","updated":"2022-07-29T04:01:07.041Z","comments":true,"path":"2022/07/20/2022-7-22/","link":"","permalink":"http://example.com/2022/07/20/2022-7-22/","excerpt":"","text":"Eexception(异常处理)重点！！！！异常介绍： java语言中 将程序执行中发生的不正常情况下称为 “异常”语法错误或者逻辑错误不是异常 执行过程中所发生的异常事件可以分为两类 Error Java虚拟机无法解决的严重错误 如JVM 系统内部错误 资源耗尽等 Exception：其他因编程错误或偶然或偶然的外的元素导致的一般性问题 Exception分两大类 运行时异常（程序运行时发生的异常）和编译时异常（在编写程序时 编译检查出的异常） 异常处理的体系图常见的运行时异常包括 NullPointerException 空指针异常(当应用程序在需要对象的地方使用null时程序抛出异常演示NullpointException.java) ArithmeticException 数字运算异常 ArrayIndexOutOfBoundException 数组下标越界异常 ClassCastException 类型转换异常 NumberFormatException 数字格式不正确异常[] 常见的编译异常 SQLException //操作数据库 查询表可能发生的异常 IOException //操作文件时，发生的异常 FileNotFoundException //当操作一个不存在的文件时 发生异常 ClassNotFoundException //操作文件到文件尾部发生异常 IllegalArgumentException //参数异常 异常处理基本介绍异常处理就当异常发生时对异常处理的方式 异常处理的方式1.try-catch-finally 程序员在代码中捕获发生的异常 自行处理 2.throws 将反生的异常抛出 交给调用者来处理 最顶级的处理是JVM 基本的语法 try{ //可疑代码 //将异常生成的对应的异常对象，传递给catch }catch(异常){ //对异常的处理 }//如果没有finally语法可疑通过 123456789101112 try &#123; String str=&quot;Awei&quot;; int a=Integer.parseInt(str);//这里只要错了下面的代码不会执行 直接到catch System.out.println(&quot;数字：&quot;+ a); &#125; catch (NumberFormatException e) &#123; System.out.println(&quot;异常的信息&quot;+e.getMessage()); &#125;finally&#123; System.out.println(&quot;finally 被执行&quot;)//不管代码会不会错 finally代码块会被执行 &#125; System.out.println(&quot;程序继续&quot;);//这里还是会继续执行 &#125;//如果代码不会错 不会执行Catch 如果try代码块要可能多个异常可以通过多个catch分别处理 但是父类的异常必须写在后面 1234567891011121314151617181920212223242526272829303132333435363738try &#123; Person person = new Person(); person=null; System.out.println(person.getName());//NullpointExceptoin int n1 = 10; int n2 = 0; int res = n1 / n2;//ArithmenticException &#125; catch (NullPointerException e) &#123; System.out.println(&quot;空指针=&quot; + e.getMessage()); &#125; catch (ArithmeticException e) &#123; System.out.println(&quot;算数异常：&quot; + e.getMessage()); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; finally &#123; &#125; &#125;&#125;class Person &#123; private String name = &quot;jack&quot;; public String getName() &#123; return name; &#125;&#125; /* 可以进行 try-finally配合使用，这种用法相当于没有捕获异常 因此程序会直接崩掉应用场景就是一段代码不管发生异常都会执行finally */ try &#123; int n1=10; int n2=2; System.out.println(n1/n2); &#125;finally &#123; System.out.println(&quot;执行了finally&quot;); &#125; System.out.println(&quot;程序继续执行 &quot;); throw异常抛出基本介绍如果一个方法（中的语句执行时）可能造成某种异常 但是不确定如何处理这种异常 则此方法应显示的声明抛出异常 表面该方法不对这些异常处理进行处理 而由该方法调用者负责 在方法声明中用throw语句可以声明抛出异常的列表 throws后面的异常类型可以是方法中产生的异常类型 也是是他的父类 123456789101112public static void main(String[] args) &#123; &#125; public void f2() throws Exception &#123; //创建一个文件流对象 //这里的异 常时一个fileNotFoundException 编译异常 //使用try-cath-finally //使用throws抛出异常 让调用f2方法的调用者来处理 //throws可以反生的异常类型 也可以是它的父类 //可以抛出多个异常 FileInputStream fileInputStream = new FileInputStream(&quot;d://aa.txt&quot;); &#125; 12345678910111213141516171819202122# String StirngBuffer和StringBuilder的比较1. StringBuilder和String Buffer非常类似 均可以代表字符串的序列 而且方法也一样2. String:不可以变字符序列 效率低 但是复用性高3. StringBuffer:可变字符序列，效率高 线程安全 4. StringBuilder 可变字符序列 效率最高 但是线程不安全5. String的使用说明 1. String s=&quot;a&quot;;//创建了一个字符串 2. s+=“b”//实际上原理的a字符串已经丢失现在又是重新生产了一个字符串 System.currentTimeMillis记录当前时间 String StringBuffer StringBuilder的选择 1.如果字符串存在大量的修改操作 一般使用StringBuffer和StringBuilder 2.如果字符串存在大量的修改操作 并是单线程的情况下 使用StringBuilder 3.如果字符串存在大量的修改操作 并是多线程的情况下 使用StringBuffer 4.如果我们的字符很少修改,别多个对象引用，使用String StringBuilder 的方法很StringBuffer的方法是一致的 ArraList的底层结构和源码分析 ArrayList的底层底层操作机制ArrayList中维护了 Object类型的数组elementData 当创建ArrayList对象时 如果使用的是无参构造器 则初始换elementData容量为0 第一次添加 则扩容为10 如果需要再次扩容 则会扩容1.5倍 如果需要使用指定大小的构造器 则初始化elementData容量为指定大小 如果需要扩容则会扩容elementData为1.5倍 简单的来讲 如果没有指定大小 初始化为0 添加输入对象变为10 不够时扩容1.5倍 如果指定了大小初始化就是自己指定的大小如果需要扩容就增加1.5倍 ArraList的底层是一个element Object[]的数组 ArrayList的常用方法add 添加 addall添加多个元素 remove移除某个对象 removeall 移除多个对象 indexof查找第一个对象 lastindexof查找某个元素在ArrayList中的元素最后出现的下标 set修改某个元素 subList 截取ArrayList某个子集 Vector和ArrayList的区别Vector是线程同步的 即线程安全的因为带有synchronized的方法 在开发中需要线程同步就是要vector 则单线程使用ArrayList 效率高 Vector的底层结构相比ArrayList 线程安全 线程同步但是效率不高 扩容机制： 如果是无参构造器 默认10 满了后就按照两倍扩容 如果是指定大小 满了后就按照两倍扩容 LinkedList LinkedList实现了双向列表和双端队列的特点 可添加任意元素 包括null 线程不安全 没有实现同步 ArrayList跟LinkedList的比较ArrayList可变数组 增加删除的效率较低 数组扩容 改查的效率较高 LinkedList双向列表 增加删除的效率高 通过列表增加删除 改查的效率较低 Set接口 无序 不允许重复的元素 最多包含一个null JDK API中Set接口的实现类 HashSet HashSet的底层还是HashMap 添加一个元素时 先得到hash值 会转成索引值 找到存储表table 看到这个索引位置是否有已经存放的元素 如果没有直接加入 如果有 调用equals比较 如果相同就放弃添加 如果不同则添加在后面 在java8中 如果一条列表的元素个数到达8时 且table表的的大小到64后会变化为红黑树 HashSet底层是Hashmap 第一次添加是 table数组扩容到16 临界值是12 如果table数组到达十二的临界值就是扩容到32 新的临界值就是24 如果一条列表的元素到达了 8个时 也会扩容到两倍 但是一旦扩容到64时就会变成红黑树 扩容机制 每次添加一个元素seize都会++ size一道12个时就扩容 链表到达8个时也会扩容","categories":[],"tags":[]}],"categories":[],"tags":[]}